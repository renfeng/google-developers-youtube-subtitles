1
00:00:00,000 --> 00:00:02,630
 

2
00:00:02,630 --> 00:00:05,160
这不是什么秘密
成功的应用

3
00:00:05,160 --> 00:00:08,550
必须要有用户，然而
为了不断地创造价值

4
00:00:08,550 --> 00:00:10,225
有时需要让应用持续运行

5
00:00:10,225 --> 00:00:12,100
这并不容易
当手机休眠的时候

6
00:00:12,100 --> 00:00:13,590
我想说的是
你该怎么办呢？

7
00:00:13,590 --> 00:00:15,673
唤醒电话进行工作吗？
即使已经休眠了？

8
00:00:15,673 --> 00:00:18,180
嗯是的，必须的
不过要小心

9
00:00:18,180 --> 00:00:20,682
电量会是个大麻烦

10
00:00:20,682 --> 00:00:23,140
我叫 Colt McAnlis.
打扰你的手机的美容觉

11
00:00:23,140 --> 00:00:25,390
在 Android 设备上
是造成不必要的耗电的罪魁祸首之一

12
00:00:25,390 --> 00:00:27,829
不过，稍微改变一下工作方式

13
00:00:27,829 --> 00:00:30,120
你可以取得相同的结果

14
00:00:30,120 --> 00:00:31,830
同时减少电量消耗

15
00:00:31,830 --> 00:00:34,630
为了形象一点
我们来聊聊我的好朋友 Reto

16
00:00:34,630 --> 00:00:37,070
他是一个狂热的社交用户和游戏玩家

17
00:00:37,070 --> 00:00:39,490
就是说
他常用的应用都在不停地

18
00:00:39,490 --> 00:00:42,100
检查排行榜
上传照片

19
00:00:42,100 --> 00:00:44,800
下载最新的热门标签

20
00:00:44,800 --> 00:00:47,770
即使 Reto 让他的手机休眠

21
00:00:47,770 --> 00:00:50,300
到吃午饭的时候
他的手机已经没电了

22
00:00:50,300 --> 00:00:52,630
Reto 必须经常给他的手机充电

23
00:00:52,630 --> 00:00:54,817
因为他的手机睡眠不足

24
00:00:54,817 --> 00:00:56,900
就是说
因为这些应用程序

25
00:00:56,900 --> 00:00:59,080
不断地唤醒手机
消耗电量

26
00:00:59,080 --> 00:01:02,751
他的手机得不到休眠
而休眠是重要的

27
00:01:02,751 --> 00:01:04,209
请记住
Android 会关闭

28
00:01:04,209 --> 00:01:05,970
各种硬件部件

29
00:01:05,970 --> 00:01:07,500
以延长电池寿命

30
00:01:07,500 --> 00:01:09,840
首先，屏幕会变暗
然后关闭

31
00:01:09,840 --> 00:01:11,570
最后，CPU 进入睡眠

32
00:01:11,570 --> 00:01:14,860
所有的一切是为了保存宝贵的

33
00:01:14,860 --> 00:01:16,210
宝贵的电量

34
00:01:16,210 --> 00:01:19,140
但即使处在这种非活动状态
很多应用会尝试进行工作

35
00:01:19,140 --> 00:01:21,712
他们将不得不唤醒手机

36
00:01:21,712 --> 00:01:23,920
对于一个应用
唤醒你的手机

37
00:01:23,920 --> 00:01:27,580
进行工作的最简单的方法是调用 API
PowerManager.Wakelock

38
00:01:27,580 --> 00:01:29,270
这可以用来保持 CPU 运行

39
00:01:29,270 --> 00:01:31,615
和防止屏幕变暗或关闭

40
00:01:31,615 --> 00:01:33,490
这使您的手机可以做一些事情

41
00:01:33,490 --> 00:01:35,370
例如到某个时间醒过来
做一些工作

42
00:01:35,370 --> 00:01:37,195
然后再让手机回去睡觉

43
00:01:37,195 --> 00:01:39,320
但是，就是最后那一部分最麻烦

44
00:01:39,320 --> 00:01:41,660
你看，获取 Wakelock 其实很容易

45
00:01:41,660 --> 00:01:44,430
如何释放才是问题

46
00:01:44,430 --> 00:01:47,220
很多种可能会导致严重错误

47
00:01:47,220 --> 00:01:50,360
出现这样的情况怎么办
如果你的应用需要60分钟

48
00:01:50,360 --> 00:01:52,180
而不是所期望的10秒钟

49
00:01:52,180 --> 00:01:54,810
来分析一些图像
然后再上传服务器

50
00:01:54,810 --> 00:01:56,840
或者，出现那样的情况怎么办
如果服务器崩溃

51
00:01:56,840 --> 00:01:59,030
导致你 ping 社交媒体
却收不到响应

52
00:01:59,030 --> 00:02:01,620
最后永远等不到一个结果

53
00:02:01,620 --> 00:02:03,947
最终结果是手机无法休眠
耗尽电量

54
00:02:03,947 --> 00:02:06,530
这也正是为什么要使用

55
00:02:06,530 --> 00:02:10,229
带超时参数的
wakelock.acquire

56
00:02:10,229 --> 00:02:12,020
这将迫使 Wakelock
得到释放

57
00:02:12,020 --> 00:02:14,840
在指定的时间之后
以防出现

58
00:02:14,840 --> 00:02:16,771
类似的特殊情况

59
00:02:16,771 --> 00:02:18,770
但是，这并不能完全解决问题

60
00:02:18,770 --> 00:02:20,936
就是说
超时该设置为多少

61
00:02:20,936 --> 00:02:23,960
或者，该等多久
然后再重试

62
00:02:23,960 --> 00:02:25,920
一旦第一次尝试失败

63
00:02:25,920 --> 00:02:29,290
正确的解决方案
似乎是使用非精确定时器

64
00:02:29,290 --> 00:02:31,760
通常，你设置一个未来的时间

65
00:02:31,760 --> 00:02:33,370
来触发你的事件
并唤醒手机

66
00:02:33,370 --> 00:02:35,500
但更好的做法可能是
选择不同的时机

67
00:02:35,500 --> 00:02:37,170
以便节省电量

68
00:02:37,170 --> 00:02:39,170
举个例子
如果另一个应用程序

69
00:02:39,170 --> 00:02:42,590
需要比你的
晚五分钟唤醒手机

70
00:02:42,590 --> 00:02:44,130
最好能等到那时

71
00:02:44,130 --> 00:02:46,950
这样就可以把工作
集中在一起做

72
00:02:46,950 --> 00:02:49,370
这就是非精确
定时器的工作原理

73
00:02:49,370 --> 00:02:51,120
您可以为将来
安排一些工作

74
00:02:51,120 --> 00:02:53,328
但是，如果系统检测到
一个更好的时间

75
00:02:53,328 --> 00:02:55,620
就可以推迟你的工作
以节省电量

76
00:02:55,620 --> 00:02:59,180
而在现实中
还有另外的一大类场景

77
00:02:59,180 --> 00:03:02,030
对于耗电量大的工作来说
最佳时机是

78
00:03:02,030 --> 00:03:04,580
例如，当手机正在充电
或者连接到 Wi-Fi

79
00:03:04,580 --> 00:03:06,710
或者已经被另一个进程唤醒

80
00:03:06,710 --> 00:03:09,790
如果您的工作可以
推迟到将来的一个时间

81
00:03:09,790 --> 00:03:11,650
当这些条件
比较理想的时候

82
00:03:11,650 --> 00:03:14,930
那就可以显著地
延长电池寿命

83
00:03:14,930 --> 00:03:18,290
JobScheduler API
正是用来做这个的

84
00:03:18,290 --> 00:03:21,100
你看，这个 API 最适合用来
安排某些工作在未来执行

85
00:03:21,100 --> 00:03:23,757
以获得各种
理想的条件组合

86
00:03:23,757 --> 00:03:25,840
例如，等到设备充电

87
00:03:25,840 --> 00:03:28,010
等到连上 Wi-Fi

88
00:03:28,010 --> 00:03:29,760
或者把任务集中起来
批量执行

89
00:03:29,760 --> 00:03:31,820
基本上，通过一个简单的 API

90
00:03:31,820 --> 00:03:33,450
你可以免费获得
所有的调度算法

91
00:03:33,450 --> 00:03:36,340
还有，别忘了自从手机上有了
新的电量使用报告

92
00:03:36,340 --> 00:03:38,250
现在用户可以看到

93
00:03:38,250 --> 00:03:41,550
你的应用让他们的手机
醒了多长时间

94
00:03:41,550 --> 00:03:43,710
并且可以卸载你的应用

95
00:03:43,710 --> 00:03:46,660
就从同一个屏幕上
这意味着你应该

96
00:03:46,660 --> 00:03:48,660
多花几分钟时间

97
00:03:48,660 --> 00:03:51,790
通过 Battery Historian 工具来确保所有的
wakelock 逻辑秩序井然

98
00:03:51,790 --> 00:03:53,040
 

99
00:03:53,040 --> 00:03:55,280
该工具是和 Android L
一起发布的

100
00:03:55,280 --> 00:03:58,130
可以用来了解
唤醒的频率

101
00:03:58,130 --> 00:04:00,480
谁发起的
持续了多久

102
00:04:00,480 --> 00:04:03,000
一目了然

103
00:04:03,000 --> 00:04:06,030
有了这些新工具和 API
你终于可以

104
00:04:06,030 --> 00:04:08,440
给缺乏睡眠的手机
一些应得的休息了

105
00:04:08,440 --> 00:04:11,222
不过，如果是你
还不想睡觉

106
00:04:11,222 --> 00:04:13,680
那就去看看
Andr​​oid 性能模式系列的其他短片

107
00:04:13,680 --> 00:04:16,160
还有，别忘了加入
我们的 Google+ 社区

108
00:04:16,160 --> 00:04:17,339
 

109
00:04:17,339 --> 00:04:19,929
保持冷静，分析你的代码
并永远记住

110
00:04:19,929 --> 00:04:21,429
性能攸关

111
00:04:21,429 --> 00:04:25,079
[音乐播放]

112
00:04:25,079 --> 00:04:39,288
 

